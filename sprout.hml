// Sprout - Express.js style web framework for Hemlock
// A lightweight, fast, and flexible web framework

import { TcpListener, TcpStream } from "@stdlib/net";
import { parse as json_parse, stringify as json_stringify } from "@stdlib/json";

// ============================================================================
// HTTP Status Codes
// ============================================================================

// HTTP status codes are handled via function below

// ============================================================================
// Utility Functions
// ============================================================================

export fn get_status_text(code) {
    if (code == 100) { return "Continue"; }
    if (code == 101) { return "Switching Protocols"; }
    if (code == 200) { return "OK"; }
    if (code == 201) { return "Created"; }
    if (code == 202) { return "Accepted"; }
    if (code == 204) { return "No Content"; }
    if (code == 301) { return "Moved Permanently"; }
    if (code == 302) { return "Found"; }
    if (code == 303) { return "See Other"; }
    if (code == 304) { return "Not Modified"; }
    if (code == 307) { return "Temporary Redirect"; }
    if (code == 308) { return "Permanent Redirect"; }
    if (code == 400) { return "Bad Request"; }
    if (code == 401) { return "Unauthorized"; }
    if (code == 403) { return "Forbidden"; }
    if (code == 404) { return "Not Found"; }
    if (code == 405) { return "Method Not Allowed"; }
    if (code == 406) { return "Not Acceptable"; }
    if (code == 408) { return "Request Timeout"; }
    if (code == 409) { return "Conflict"; }
    if (code == 410) { return "Gone"; }
    if (code == 411) { return "Length Required"; }
    if (code == 413) { return "Payload Too Large"; }
    if (code == 414) { return "URI Too Long"; }
    if (code == 415) { return "Unsupported Media Type"; }
    if (code == 422) { return "Unprocessable Entity"; }
    if (code == 429) { return "Too Many Requests"; }
    if (code == 500) { return "Internal Server Error"; }
    if (code == 501) { return "Not Implemented"; }
    if (code == 502) { return "Bad Gateway"; }
    if (code == 503) { return "Service Unavailable"; }
    if (code == 504) { return "Gateway Timeout"; }
    return "Unknown";
}

fn trim_string(s) {
    return s.trim();
}

fn to_lower(s) {
    return s.to_lower();
}

export fn split_once(s, delim) {
    let idx = s.find(delim);
    if (idx == -1) {
        return [s, ""];
    }
    return [s.substr(0, idx), s.substr(idx + delim.length, s.length - idx - delim.length)];
}

export fn url_decode(s) {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s.char_at(i);
        if (ch == '%' && i + 2 < s.length) {
            let hex = s.substr(i + 1, 2);
            let code = parse_hex(hex);
            if (code >= 0) {
                result = result + rune_to_string(code);
                i = i + 3;
                continue;
            }
        } else if (ch == '+') {
            result = result + " ";
            i = i + 1;
            continue;
        }
        result = result + rune_to_string(ch);
        i = i + 1;
    }
    return result;
}

fn parse_hex(s) {
    let result = 0;
    for (let i = 0; i < s.length; i = i + 1) {
        let ch = s.char_at(i);
        let ch_code: i32 = ch;
        let val = -1;
        if (ch >= '0' && ch <= '9') {
            let zero_code: i32 = '0';
            val = ch_code - zero_code;
        } else if (ch >= 'a' && ch <= 'f') {
            let a_code: i32 = 'a';
            val = ch_code - a_code + 10;
        } else if (ch >= 'A' && ch <= 'F') {
            let A_code: i32 = 'A';
            val = ch_code - A_code + 10;
        }
        if (val == -1) {
            return -1;
        }
        result = result * 16 + val;
    }
    return result;
}

fn rune_to_string(r) {
    let s = " ";
    let code: i32 = r;
    s[0] = code;
    return s;
}

fn buffer_to_string(buf) {
    if (buf == null || buf.length == 0) {
        return "";
    }
    // Pre-allocate string of correct length by repeating a character
    let result = "";
    for (let i = 0; i < buf.length; i = i + 1) {
        result = result + " ";
    }
    // Now fill in the actual bytes
    for (let i = 0; i < buf.length; i = i + 1) {
        let b: i32 = buf[i];
        result[i] = b;
    }
    return result;
}

export fn parse_query_string(qs) {
    let result = {};
    if (qs == "" || qs == null) {
        return result;
    }
    let pairs = qs.split("&");
    for (let pair in pairs) {
        if (pair == "") {
            continue;
        }
        let parts = split_once(pair, "=");
        let key = url_decode(parts[0]);
        let value = url_decode(parts[1]);
        result[key] = value;
    }
    return result;
}

export fn parse_cookies(cookie_header) {
    let result = {};
    if (cookie_header == "" || cookie_header == null) {
        return result;
    }
    let pairs = cookie_header.split(";");
    for (let pair in pairs) {
        let trimmed = trim_string(pair);
        if (trimmed == "") {
            continue;
        }
        let parts = split_once(trimmed, "=");
        let key = trim_string(parts[0]);
        let value = trim_string(parts[1]);
        result[key] = value;
    }
    return result;
}

export fn get_content_type_category(ct) {
    if (ct == null) {
        return null;
    }
    let lower = to_lower(ct);
    if (lower.contains("application/json")) {
        return "json";
    }
    if (lower.contains("text/html")) {
        return "html";
    }
    if (lower.contains("text/plain")) {
        return "text";
    }
    if (lower.contains("application/x-www-form-urlencoded")) {
        return "urlencoded";
    }
    if (lower.contains("multipart/form-data")) {
        return "multipart";
    }
    if (lower.contains("text/xml") || lower.contains("application/xml")) {
        return "xml";
    }
    return null;
}

export fn get_mime_type(extension) {
    let ext = to_lower(extension);
    if (ext == "html" || ext == "htm") { return "text/html; charset=utf-8"; }
    if (ext == "css") { return "text/css; charset=utf-8"; }
    if (ext == "js") { return "application/javascript; charset=utf-8"; }
    if (ext == "json") { return "application/json; charset=utf-8"; }
    if (ext == "png") { return "image/png"; }
    if (ext == "jpg" || ext == "jpeg") { return "image/jpeg"; }
    if (ext == "gif") { return "image/gif"; }
    if (ext == "svg") { return "image/svg+xml"; }
    if (ext == "ico") { return "image/x-icon"; }
    if (ext == "pdf") { return "application/pdf"; }
    if (ext == "txt") { return "text/plain; charset=utf-8"; }
    if (ext == "xml") { return "application/xml; charset=utf-8"; }
    if (ext == "woff") { return "font/woff"; }
    if (ext == "woff2") { return "font/woff2"; }
    if (ext == "ttf") { return "font/ttf"; }
    if (ext == "eot") { return "application/vnd.ms-fontobject"; }
    if (ext == "mp3") { return "audio/mpeg"; }
    if (ext == "mp4") { return "video/mp4"; }
    if (ext == "webm") { return "video/webm"; }
    if (ext == "webp") { return "image/webp"; }
    if (ext == "zip") { return "application/zip"; }
    if (ext == "gz") { return "application/gzip"; }
    return "application/octet-stream";
}

export fn get_extension(path) {
    let last_dot = -1;
    let last_slash = -1;
    for (let i = 0; i < path.length; i = i + 1) {
        let ch = path.char_at(i);
        if (ch == '.') {
            last_dot = i;
        }
        if (ch == '/') {
            last_slash = i;
        }
    }
    if (last_dot == -1 || last_dot < last_slash) {
        return "";
    }
    return path.substr(last_dot + 1, path.length - last_dot - 1);
}

export fn get_basename(path) {
    let last_slash = -1;
    for (let i = 0; i < path.length; i = i + 1) {
        if (path.char_at(i) == '/') {
            last_slash = i;
        }
    }
    if (last_slash == -1) {
        return path;
    }
    return path.substr(last_slash + 1, path.length - last_slash - 1);
}

export fn normalize_path(path) {
    if (path == "" || path == null) {
        return "/";
    }
    // Ensure starts with /
    if (path.char_at(0) != '/') {
        path = "/" + path;
    }
    return path;
}

fn paths_equal(p1, p2, case_sensitive) {
    if (case_sensitive) {
        return p1 == p2;
    }
    return to_lower(p1) == to_lower(p2);
}

export fn remove_trailing_slash(path) {
    if (path.length > 1 && path.char_at(path.length - 1) == '/') {
        return path.substr(0, path.length - 1);
    }
    return path;
}

// ============================================================================
// Path Pattern Matching
// ============================================================================

export fn compile_path_pattern(pattern) {
    let segments = [];
    let parts = pattern.split("/");

    for (let part in parts) {
        if (part == "") {
            continue;
        }

        let segment = {
            type: "literal",
            name: null,
            value: part,
            optional: false,
            regex: null
        };

        // Check for wildcard
        if (part == "*") {
            segment.type = "wildcard";
            segments.push(segment);
            continue;
        }

        // Check for parameter :name or :name?
        if (part.length > 0 && part.char_at(0) == ':') {
            let name = part.substr(1, part.length - 1);
            let optional = false;
            let regex = null;

            // Check for optional marker
            if (name.length > 0 && name.char_at(name.length - 1) == '?') {
                name = name.substr(0, name.length - 1);
                optional = true;
            }

            // Check for regex constraint :name(pattern)
            let paren_idx = name.find("(");
            if (paren_idx != -1) {
                let paren_end = name.find(")");
                if (paren_end > paren_idx) {
                    regex = name.substr(paren_idx + 1, paren_end - paren_idx - 1);
                    name = name.substr(0, paren_idx);
                }
            }

            segment.type = "param";
            segment.name = name;
            segment.optional = optional;
            segment.regex = regex;
            segments.push(segment);
            continue;
        }

        // Literal segment
        segments.push(segment);
    }

    return {
        original: pattern,
        segments: segments
    };
}

export fn match_path(compiled, path, case_sensitive) {
    let parts = path.split("/");
    let path_segments = [];
    for (let part in parts) {
        if (part != "") {
            path_segments.push(part);
        }
    }

    let params = {};
    let pattern_segments = compiled.segments;
    let pi = 0;  // path index
    let pti = 0; // pattern index

    while (pti < pattern_segments.length) {
        let seg = pattern_segments[pti];

        if (seg.type == "wildcard") {
            // Wildcard matches rest of path
            let rest = [];
            while (pi < path_segments.length) {
                rest.push(path_segments[pi]);
                pi = pi + 1;
            }
            params["*"] = rest.join("/");
            pti = pti + 1;
            continue;
        }

        if (seg.type == "param") {
            if (pi >= path_segments.length) {
                if (seg.optional) {
                    params[seg.name] = null;
                    pti = pti + 1;
                    continue;
                }
                return null; // Required param missing
            }

            let value = path_segments[pi];

            // Check regex constraint
            if (seg.regex != null) {
                let valid = match_simple_regex(value, seg.regex);
                if (!valid) {
                    return null;
                }
            }

            params[seg.name] = value;
            pi = pi + 1;
            pti = pti + 1;
            continue;
        }

        // Literal segment
        if (pi >= path_segments.length) {
            return null;
        }

        if (!paths_equal(seg.value, path_segments[pi], case_sensitive)) {
            return null;
        }

        pi = pi + 1;
        pti = pti + 1;
    }

    // Check if all path segments were consumed (unless wildcard was used)
    if (pi < path_segments.length) {
        // Check if last pattern was wildcard
        if (pattern_segments.length > 0) {
            let last = pattern_segments[pattern_segments.length - 1];
            if (last.type != "wildcard") {
                return null;
            }
        } else {
            return null;
        }
    }

    return params;
}

fn match_simple_regex(value, pattern) {
    // Simple regex matching for patterns like "v1|v2"
    let options = pattern.split("|");
    for (let opt in options) {
        if (value == opt) {
            return true;
        }
    }
    return false;
}

// ============================================================================
// Request Object
// ============================================================================

export fn create_request(method, url, headers, body, app_options) {
    let path = url;
    let query_string = "";

    // Split URL into path and query
    let q_idx = url.find("?");
    if (q_idx != -1) {
        path = url.substr(0, q_idx);
        query_string = url.substr(q_idx + 1, url.length - q_idx - 1);
    }

    let query = parse_query_string(query_string);

    // Parse cookies
    let cookie_header = "";
    if (headers["cookie"] != null) {
        cookie_header = headers["cookie"];
    }
    let cookies = parse_cookies(cookie_header);

    // Parse body if JSON
    let parsed_body = null;
    let content_type = headers["content-type"];
    if (content_type != null && body != "") {
        let ct_category = get_content_type_category(content_type);
        if (ct_category == "json") {
            try {
                parsed_body = json_parse(body);
            } catch (e) {
                parsed_body = null;
            }
        } else if (ct_category == "urlencoded") {
            parsed_body = parse_query_string(body);
        }
    }

    // Get IP address
    let ip = "";
    let ips = [];
    if (app_options.trust_proxy && headers["x-forwarded-for"] != null) {
        let forwarded = headers["x-forwarded-for"];
        ips = forwarded.split(",");
        for (let i = 0; i < ips.length; i = i + 1) {
            ips[i] = trim_string(ips[i]);
        }
        if (ips.length > 0) {
            ip = ips[0];
        }
    }

    // Get protocol
    let protocol = "http";
    if (app_options.trust_proxy && headers["x-forwarded-proto"] != null) {
        protocol = to_lower(headers["x-forwarded-proto"]);
    }

    return {
        method: method,
        path: path,
        url: url,
        protocol: protocol,
        headers: headers,
        query: query,
        cookies: cookies,
        body: parsed_body,
        raw_body: body,
        params: {},
        ip: ip,
        ips: ips,
        app: null,

        // Methods
        get: fn(name, default_val) {
            let lower_name = to_lower(name);
            if (self.headers[lower_name] != null) {
                return self.headers[lower_name];
            }
            if (default_val != null) {
                return default_val;
            }
            return null;
        },

        has: fn(name) {
            let lower_name = to_lower(name);
            return self.headers[lower_name] != null;
        },

        is: fn(type_name) {
            let ct = self.headers["content-type"];
            if (ct == null) {
                return false;
            }
            let category = get_content_type_category(ct);
            return category == type_name;
        },

        accepts: fn(type_name) {
            let accept = self.headers["accept"];
            if (accept == null) {
                return true;
            }
            if (accept.contains("*/*")) {
                return true;
            }
            let lower_type = to_lower(type_name);
            if (lower_type == "json") {
                return accept.contains("application/json") || accept.contains("*/*");
            }
            if (lower_type == "html") {
                return accept.contains("text/html") || accept.contains("*/*");
            }
            if (lower_type == "text") {
                return accept.contains("text/plain") || accept.contains("text/*") || accept.contains("*/*");
            }
            return accept.contains(type_name);
        }
    };
}

// ============================================================================
// Response Object
// ============================================================================

export fn create_response(stream) {
    let default_headers = {};
    default_headers["content-type"] = "text/html; charset=utf-8";

    return {
        _stream: stream,
        _status: 200,
        _headers: default_headers,
        _sent: false,
        _cookies: [],
        _chunks: [],

        // Set status code (chainable)
        status: fn(code) {
            self._status = code;
            return self;
        },

        // Set header (chainable)
        set: fn(name, value) {
            if (typeof(name) == "object") {
                // Multiple headers passed as object
                let obj = name;
                // Note: Hemlock doesn't have object iteration, so we handle common cases
                if (obj["content-type"] != null) { self._headers["content-type"] = obj["content-type"]; }
                if (obj["Content-Type"] != null) { self._headers["content-type"] = obj["Content-Type"]; }
                if (obj["cache-control"] != null) { self._headers["cache-control"] = obj["cache-control"]; }
                if (obj["Cache-Control"] != null) { self._headers["cache-control"] = obj["Cache-Control"]; }
                if (obj["x-foo"] != null) { self._headers["x-foo"] = obj["x-foo"]; }
                if (obj["X-Foo"] != null) { self._headers["x-foo"] = obj["X-Foo"]; }
                if (obj["x-baz"] != null) { self._headers["x-baz"] = obj["x-baz"]; }
                if (obj["X-Baz"] != null) { self._headers["x-baz"] = obj["X-Baz"]; }
                return self;
            }
            let lower_name = to_lower(name);
            self._headers[lower_name] = value;
            return self;
        },

        header: fn(name, value) {
            return self.set(name, value);
        },

        // Set content type
        type: fn(content_type) {
            if (!content_type.contains("/")) {
                // It's an extension
                content_type = get_mime_type(content_type);
            }
            self._headers["content-type"] = content_type;
            return self;
        },

        // Set cookie
        cookie: fn(name, value, options) {
            let cookie_str = name + "=" + value;
            if (options != null) {
                if (options["max_age"] != null) {
                    cookie_str = cookie_str + "; Max-Age=" + options["max_age"];
                }
                if (options["http_only"] == true) {
                    cookie_str = cookie_str + "; HttpOnly";
                }
                if (options["secure"] == true) {
                    cookie_str = cookie_str + "; Secure";
                }
                if (options["same_site"] != null) {
                    cookie_str = cookie_str + "; SameSite=" + options["same_site"];
                }
                if (options["path"] != null) {
                    cookie_str = cookie_str + "; Path=" + options["path"];
                }
                if (options["domain"] != null) {
                    cookie_str = cookie_str + "; Domain=" + options["domain"];
                }
            }
            self._cookies.push(cookie_str);
            return self;
        },

        clear_cookie: fn(name) {
            self._cookies.push(name + "=; Max-Age=0");
            return self;
        },

        // Add Vary header
        vary: fn(header_name) {
            let existing = self._headers["vary"];
            if (existing == null || existing == "") {
                self._headers["vary"] = header_name;
            } else {
                self._headers["vary"] = existing + ", " + header_name;
            }
            return self;
        },

        // Send response
        send: fn(body) {
            if (self._sent) {
                return;
            }

            let body_str = "";
            if (typeof(body) == "object" || typeof(body) == "array") {
                self._headers["content-type"] = "application/json; charset=utf-8";
                body_str = json_stringify(body);
            } else if (body != null) {
                body_str = "" + body;
            }

            self._send_response(body_str);
        },

        // Send JSON response
        json: fn(data) {
            if (self._sent) {
                return;
            }
            self._headers["content-type"] = "application/json; charset=utf-8";
            let body_str = json_stringify(data);
            self._send_response(body_str);
        },

        // Redirect
        redirect: fn(url_or_status, url?: null) {
            if (self._sent) {
                return;
            }

            let status_code = 302;
            let redirect_url = url_or_status;

            if (typeof(url_or_status) == "i32" || typeof(url_or_status) == "integer") {
                status_code = url_or_status;
                redirect_url = url;
            }

            self._status = status_code;
            self._headers["location"] = redirect_url;
            self._send_response("");
        },

        // Send file
        send_file: fn(file_path) {
            if (self._sent) {
                return;
            }

            try {
                let f = open(file_path, "r");
                defer f.close();
                let content = f.read();

                let ext = get_extension(file_path);
                self._headers["content-type"] = get_mime_type(ext);
                self._send_response(content);
            } catch (e) {
                self._status = 404;
                self._send_response("File not found");
            }
        },

        // Download file
        download: fn(file_path, filename) {
            if (self._sent) {
                return;
            }

            let dl_name = filename;
            if (dl_name == null) {
                dl_name = get_basename(file_path);
            }

            self._headers["content-disposition"] = "attachment; filename=\"" + dl_name + "\"";
            self.send_file(file_path);
        },

        // Render template (basic implementation)
        render: fn(template_path, data) {
            if (self._sent) {
                return;
            }

            try {
                let f = open(template_path, "r");
                defer f.close();
                let content = f.read();

                // Basic template substitution: {{key}}
                if (data != null) {
                    // Since we can't iterate objects, just send as-is
                    // Users would need to do their own template processing
                }

                self._headers["content-type"] = "text/html; charset=utf-8";
                self._send_response(content);
            } catch (e) {
                self._status = 500;
                self._send_response("Template not found");
            }
        },

        // Content negotiation
        format: fn(handlers) {
            if (self._sent) {
                return;
            }

            // Check for specific handlers
            if (handlers["text/html"] != null) {
                self._headers["content-type"] = "text/html; charset=utf-8";
                handlers["text/html"]();
                return;
            }
            if (handlers["application/json"] != null) {
                self._headers["content-type"] = "application/json; charset=utf-8";
                handlers["application/json"]();
                return;
            }
            if (handlers["default"] != null) {
                handlers["default"]();
                return;
            }

            self._status = 406;
            self._send_response("Not Acceptable");
        },

        // Streaming methods
        write: fn(chunk) {
            self._chunks.push(chunk);
        },

        end: fn() {
            if (self._sent) {
                return;
            }

            let body = self._chunks.join("");
            self._send_response(body);
        },

        // Internal method to send HTTP response
        _send_response: fn(body) {
            if (self._sent) {
                return;
            }
            self._sent = true;

            let status_text = get_status_text(self._status);
            let response = "HTTP/1.1 " + self._status + " " + status_text + "\r\n";

            // Add content-length
            self._headers["content-length"] = "" + body.byte_length;

            // Add headers
            if (self._headers["content-type"] != null) {
                response = response + "Content-Type: " + self._headers["content-type"] + "\r\n";
            }
            if (self._headers["content-length"] != null) {
                response = response + "Content-Length: " + self._headers["content-length"] + "\r\n";
            }
            if (self._headers["location"] != null) {
                response = response + "Location: " + self._headers["location"] + "\r\n";
            }
            if (self._headers["cache-control"] != null) {
                response = response + "Cache-Control: " + self._headers["cache-control"] + "\r\n";
            }
            if (self._headers["vary"] != null) {
                response = response + "Vary: " + self._headers["vary"] + "\r\n";
            }
            if (self._headers["content-disposition"] != null) {
                response = response + "Content-Disposition: " + self._headers["content-disposition"] + "\r\n";
            }
            if (self._headers["access-control-allow-origin"] != null) {
                response = response + "Access-Control-Allow-Origin: " + self._headers["access-control-allow-origin"] + "\r\n";
            }
            if (self._headers["access-control-allow-methods"] != null) {
                response = response + "Access-Control-Allow-Methods: " + self._headers["access-control-allow-methods"] + "\r\n";
            }
            if (self._headers["access-control-allow-headers"] != null) {
                response = response + "Access-Control-Allow-Headers: " + self._headers["access-control-allow-headers"] + "\r\n";
            }
            if (self._headers["access-control-allow-credentials"] != null) {
                response = response + "Access-Control-Allow-Credentials: " + self._headers["access-control-allow-credentials"] + "\r\n";
            }
            if (self._headers["x-foo"] != null) {
                response = response + "X-Foo: " + self._headers["x-foo"] + "\r\n";
            }
            if (self._headers["x-baz"] != null) {
                response = response + "X-Baz: " + self._headers["x-baz"] + "\r\n";
            }
            if (self._headers["x-custom"] != null) {
                response = response + "X-Custom: " + self._headers["x-custom"] + "\r\n";
            }

            // Add cookies
            for (let cookie in self._cookies) {
                response = response + "Set-Cookie: " + cookie + "\r\n";
            }

            response = response + "Connection: close\r\n";
            response = response + "\r\n";
            response = response + body;

            self._stream.write(response);
        }
    };
}

// ============================================================================
// Router
// ============================================================================

export fn Router() {
    return {
        _routes: [],
        _middleware: [],

        // Add route for specific method
        _add_route: fn(method, path, handlers) {
            let compiled = compile_path_pattern(path);
            self._routes.push({
                method: method,
                path: path,
                compiled: compiled,
                handlers: handlers
            });
        },

        // HTTP method shortcuts
        get: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("GET", path, handlers);
            return self;
        },

        post: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("POST", path, handlers);
            return self;
        },

        put: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("PUT", path, handlers);
            return self;
        },

        delete: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("DELETE", path, handlers);
            return self;
        },

        patch: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("PATCH", path, handlers);
            return self;
        },

        head: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("HEAD", path, handlers);
            return self;
        },

        options: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("OPTIONS", path, handlers);
            return self;
        },

        all: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("*", path, handlers);
            return self;
        },

        // Add middleware
        use: fn(path_or_handler, handler?: null) {
            if (handler == null) {
                // Just a handler, no path
                self._middleware.push({
                    path: null,
                    handler: path_or_handler
                });
            } else {
                // Path and handler
                self._middleware.push({
                    path: path_or_handler,
                    handler: handler
                });
            }
            return self;
        }
    };
}

// ============================================================================
// Application
// ============================================================================

export fn App(options) {
    if (options == null) {
        options = {};
    }

    let app_options = {
        trust_proxy: false,
        case_sensitive_routing: false,
        strict_routing: false
    };

    if (options["trust_proxy"] == true) {
        app_options.trust_proxy = true;
    }
    if (options["case_sensitive_routing"] == true) {
        app_options.case_sensitive_routing = true;
    }
    if (options["strict_routing"] == true) {
        app_options.strict_routing = true;
    }

    let app = {
        _options: app_options,
        _routes: [],
        _middleware: [],
        _error_handlers: [],
        _mounted_routers: [],
        _static_routes: [],
        _listener: null,

        // Add route for specific method
        _add_route: fn(method, path, handlers) {
            let compiled = compile_path_pattern(path);
            self._routes.push({
                method: method,
                path: path,
                compiled: compiled,
                handlers: handlers
            });
        },

        // HTTP method shortcuts
        get: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("GET", path, handlers);
            return self;
        },

        post: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("POST", path, handlers);
            return self;
        },

        put: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("PUT", path, handlers);
            return self;
        },

        delete: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("DELETE", path, handlers);
            return self;
        },

        patch: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("PATCH", path, handlers);
            return self;
        },

        head: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("HEAD", path, handlers);
            return self;
        },

        options: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("OPTIONS", path, handlers);
            return self;
        },

        all: fn(path, h1, h2?: null, h3?: null, h4?: null, h5?: null) {
            let handlers = [h1];
            if (h2 != null) { handlers.push(h2); }
            if (h3 != null) { handlers.push(h3); }
            if (h4 != null) { handlers.push(h4); }
            if (h5 != null) { handlers.push(h5); }
            self._add_route("*", path, handlers);
            return self;
        },

        // Add middleware or mount router
        use: fn(path_or_handler, handler_or_router?: null) {
            if (handler_or_router == null) {
                // Just a handler/middleware, no path
                let handler = path_or_handler;

                // Check if it's a router object
                if (typeof(handler) == "object" && handler._routes != null) {
                    self._mounted_routers.push({
                        path: "",
                        router: handler
                    });
                } else {
                    self._middleware.push({
                        path: null,
                        handler: handler
                    });
                }
            } else {
                let path = path_or_handler;
                let handler = handler_or_router;

                // Check if it's a router object
                if (typeof(handler) == "object" && handler._routes != null) {
                    self._mounted_routers.push({
                        path: normalize_path(path),
                        router: handler
                    });
                } else {
                    self._middleware.push({
                        path: normalize_path(path),
                        handler: handler
                    });
                }
            }
            return self;
        },

        // Static file serving
        static: fn(url_path, dir_path, options) {
            self._static_routes.push({
                url_path: normalize_path(url_path),
                dir_path: dir_path,
                options: options
            });
            return self;
        },

        // Get underlying server
        server: fn() {
            return self._listener;
        },

        // Start HTTP server
        listen: fn(port, host_or_callback?: null, callback?: null) {
            let host = "0.0.0.0";
            let cb = null;

            if (typeof(host_or_callback) == "function") {
                cb = host_or_callback;
            } else if (host_or_callback != null) {
                host = host_or_callback;
                cb = callback;
            }

            try {
                self._listener = TcpListener(host, port);
            } catch (e) {
                print("Error: Failed to start server on " + host + ":" + port);
                print("  " + e);
                exit(1);
            }

            if (cb != null) {
                cb();
            }

            // Accept connections loop (synchronous - one connection at a time)
            while (true) {
                let stream = self._listener.accept();
                // Handle connection synchronously
                self._handle_connection_sync(stream);
            }
        },

        // Start HTTPS server (TLS)
        listen_tls: fn(port, options, callback) {
            // TLS would require additional implementation
            // For now, just start regular HTTP
            self.listen(port, callback);
        },

        // Handle a single connection synchronously
        _handle_connection_sync: fn(stream) {
            try {
                // Read request data (returns buffer)
                let raw_data = stream.read(65536);
                if (raw_data == null || raw_data.length == 0) {
                    stream.close();
                    return;
                }
                // Convert buffer to string for parsing
                let data = buffer_to_string(raw_data);
                if (data == "") {
                    stream.close();
                    return;
                }

                // Parse HTTP request
                let req_data = self._parse_request(data);
                if (req_data == null) {
                    stream.close();
                    return;
                }

                // Create request and response objects
                let req = create_request(
                    req_data.method,
                    req_data.url,
                    req_data.headers,
                    req_data.body,
                    self._options
                );
                req.app = self;

                let res = create_response(stream);

                // Process request through middleware and routes
                self._process_request(req, res);

            } catch (e) {
                // Try to send error response
                try {
                    let error_response = "HTTP/1.1 500 Internal Server Error\r\n";
                    error_response = error_response + "Content-Type: text/plain\r\n";
                    error_response = error_response + "Content-Length: 21\r\n";
                    error_response = error_response + "Connection: close\r\n\r\n";
                    error_response = error_response + "Internal Server Error";
                    stream.write(error_response);
                } catch (e2) {
                    // Ignore write errors
                }
            }

            try {
                stream.close();
            } catch (e) {
                // Ignore close errors
            }
        },

        // Parse HTTP request
        _parse_request: fn(data) {
            let lines = data.split("\r\n");
            if (lines.length == 0) {
                return null;
            }

            // Parse request line
            let request_line = lines[0];
            let parts = request_line.split(" ");
            if (parts.length < 2) {
                return null;
            }

            let method = parts[0];
            let url = parts[1];

            // Parse headers
            let headers = {};
            let body_start = -1;

            for (let i = 1; i < lines.length; i = i + 1) {
                let line = lines[i];
                if (line == "") {
                    body_start = i + 1;
                    break;
                }

                let colon_idx = line.find(":");
                if (colon_idx != -1) {
                    let name = to_lower(trim_string(line.substr(0, colon_idx)));
                    let value = trim_string(line.substr(colon_idx + 1, line.length - colon_idx - 1));
                    headers[name] = value;
                }
            }

            // Get body
            let body = "";
            if (body_start != -1 && body_start < lines.length) {
                let body_lines = [];
                for (let i = body_start; i < lines.length; i = i + 1) {
                    body_lines.push(lines[i]);
                }
                body = body_lines.join("\r\n");
            }

            return {
                method: method,
                url: url,
                headers: headers,
                body: body
            };
        },

        // Process request through middleware and routes
        _process_request: fn(req, res) {
            let path = req.path;

            // Normalize path based on options
            if (!self._options.strict_routing) {
                path = remove_trailing_slash(path);
                if (path == "") {
                    path = "/";
                }
            }

            // Collect all handlers to execute
            let handlers = [];

            // Add global middleware
            for (let mw in self._middleware) {
                if (mw.path == null || path.starts_with(mw.path)) {
                    handlers.push({
                        handler: mw.handler,
                        params: {}
                    });
                }
            }

            // Check static routes
            for (let sr in self._static_routes) {
                if (path.starts_with(sr.url_path)) {
                    let file_path = path.substr(sr.url_path.length, path.length - sr.url_path.length);
                    if (file_path == "" || file_path == "/") {
                        if (sr.options != null && sr.options.index != null) {
                            file_path = "/" + sr.options.index;
                        } else {
                            file_path = "/index.html";
                        }
                    }

                    let full_path = sr.dir_path + file_path;

                    // Check for dotfiles
                    let basename = get_basename(file_path);
                    if (basename.length > 0 && basename.char_at(0) == '.') {
                        let dotfiles = "ignore";
                        if (sr.options != null && sr.options.dotfiles != null) {
                            dotfiles = sr.options.dotfiles;
                        }
                        if (dotfiles == "ignore" || dotfiles == "deny") {
                            continue;
                        }
                    }

                    // Try to serve file
                    try {
                        let f = open(full_path, "r");
                        defer f.close();
                        let content = f.read();

                        let ext = get_extension(full_path);
                        res.set("Content-Type", get_mime_type(ext));

                        if (sr.options != null && sr.options.max_age != null) {
                            res.set("Cache-Control", "max-age=" + sr.options.max_age);
                        }

                        res.send(content);
                        return;
                    } catch (e) {
                        // File not found, continue to next handler
                    }
                }
            }

            // Check mounted routers
            for (let mr in self._mounted_routers) {
                if (path.starts_with(mr.path) || mr.path == "") {
                    let sub_path = path;
                    if (mr.path != "") {
                        sub_path = path.substr(mr.path.length, path.length - mr.path.length);
                        if (sub_path == "") {
                            sub_path = "/";
                        }
                    }

                    // Check router's middleware
                    for (let mw in mr.router._middleware) {
                        if (mw.path == null || sub_path.starts_with(mw.path)) {
                            handlers.push({
                                handler: mw.handler,
                                params: {}
                            });
                        }
                    }

                    // Check router's routes
                    for (let route in mr.router._routes) {
                        if (route.method != "*" && route.method != req.method) {
                            continue;
                        }

                        let params = match_path(route.compiled, sub_path, self._options.case_sensitive_routing);
                        if (params != null) {
                            for (let h in route.handlers) {
                                handlers.push({
                                    handler: h,
                                    params: params
                                });
                            }
                        }
                    }
                }
            }

            // Check app routes
            for (let route in self._routes) {
                if (route.method != "*" && route.method != req.method) {
                    continue;
                }

                let params = match_path(route.compiled, path, self._options.case_sensitive_routing);
                if (params != null) {
                    for (let h in route.handlers) {
                        handlers.push({
                            handler: h,
                            params: params
                        });
                    }
                }
            }

            // Execute handler chain
            let handler_index = 0;
            let error = null;

            let next = fn(err) {
                if (err != null) {
                    error = err;
                }

                if (res._sent) {
                    return;
                }

                if (handler_index >= handlers.length) {
                    // No more handlers
                    if (error != null) {
                        // Look for error handler
                        self._handle_error(error, req, res);
                    } else if (!res._sent) {
                        // No handler found - 404
                        res.status(404).send("Not Found");
                    }
                    return;
                }

                let current = handlers[handler_index];
                handler_index = handler_index + 1;

                // Update request params
                req.params = current.params;

                // Execute handler
                try {
                    if (error != null) {
                        // Skip to error handler (4-param middleware)
                        // We detect this by checking if handler length > 3
                        // Since Hemlock doesn't have a way to check param count,
                        // we'll just skip non-error handlers
                        next(error);
                    } else {
                        current.handler(req, res, next);
                    }
                } catch (e) {
                    next(e);
                }
            };

            next(null);
        },

        // Handle errors
        _handle_error: fn(error, req, res) {
            // Look for error handlers in middleware
            for (let mw in self._middleware) {
                if (mw.handler._is_error_handler == true) {
                    try {
                        mw.handler(error, req, res, fn() {});
                        if (res._sent) {
                            return;
                        }
                    } catch (e) {
                        // Error in error handler
                    }
                }
            }

            // Default error response
            if (!res._sent) {
                res.status(500).json({
                    error: "Internal Server Error",
                    message: "" + error
                });
            }
        }
    };

    return app;
}

// ============================================================================
// Built-in Middleware
// ============================================================================

// JSON body parser
export fn json() {
    return fn(req, res, next) {
        // Body is already parsed in create_request
        next();
    };
}

// URL-encoded body parser
export fn urlencoded() {
    return fn(req, res, next) {
        // Body is already parsed in create_request
        next();
    };
}

// Cookie parser
export fn cookie_parser() {
    return fn(req, res, next) {
        // Cookies are already parsed in create_request
        next();
    };
}

// CORS middleware
export fn cors(options) {
    let opts = {
        origin: "*",
        methods: ["GET", "HEAD", "PUT", "PATCH", "POST", "DELETE"],
        credentials: false
    };

    if (options != null) {
        if (options["origin"] != null) {
            opts.origin = options["origin"];
        }
        if (options["methods"] != null) {
            opts.methods = options["methods"];
        }
        if (options["credentials"] != null) {
            opts.credentials = options["credentials"];
        }
    }

    return fn(req, res, next) {
        res.set("Access-Control-Allow-Origin", opts.origin);

        let methods_str = opts.methods.join(", ");
        res.set("Access-Control-Allow-Methods", methods_str);
        res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

        if (opts.credentials == true) {
            res.set("Access-Control-Allow-Credentials", "true");
        }

        // Handle preflight
        if (req.method == "OPTIONS") {
            res.status(204).send("");
            return;
        }

        next();
    };
}

// Logger middleware
export fn logger(format) {
    let fmt = "dev";
    if (format != null) {
        fmt = format;
    }

    return fn(req, res, next) {
        let start_time = 0; // Would need @stdlib/time for actual timing

        if (fmt == "dev") {
            print(req.method + " " + req.path);
        } else if (fmt == "combined") {
            // Apache combined format
            let log_line = req.ip + " - - ";
            log_line = log_line + "\"" + req.method + " " + req.url + " HTTP/1.1\" ";
            log_line = log_line + "- - ";
            log_line = log_line + "\"" + req.get("user-agent", "-") + "\"";
            print(log_line);
        } else {
            print(req.method + " " + req.path);
        }

        next();
    };
}

// Static file middleware
export fn static_files(dir_path, options) {
    return fn(req, res, next) {
        let file_path = req.path;
        if (file_path == "" || file_path == "/") {
            if (options != null && options.index != null) {
                file_path = "/" + options.index;
            } else {
                file_path = "/index.html";
            }
        }

        let full_path = dir_path + file_path;

        // Check for dotfiles
        let basename = get_basename(file_path);
        if (basename.length > 0 && basename.char_at(0) == '.') {
            let dotfiles = "ignore";
            if (options != null && options.dotfiles != null) {
                dotfiles = options.dotfiles;
            }
            if (dotfiles == "ignore") {
                next();
                return;
            }
            if (dotfiles == "deny") {
                res.status(403).send("Forbidden");
                return;
            }
        }

        try {
            let f = open(full_path, "r");
            defer f.close();
            let content = f.read();

            let ext = get_extension(full_path);
            res.set("Content-Type", get_mime_type(ext));

            if (options != null && options.max_age != null) {
                res.set("Cache-Control", "max-age=" + options.max_age);
            }

            res.send(content);
        } catch (e) {
            next();
        }
    };
}

// Create error handler wrapper
export fn error_handler(handler) {
    return {
        _is_error_handler: true,
        handler: handler,
        call: fn(err, req, res, next) {
            self.handler(err, req, res, next);
        }
    };
}
